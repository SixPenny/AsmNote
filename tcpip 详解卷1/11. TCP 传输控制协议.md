## TCP 简介

1. tcp 向应用层提供面向连接的、可靠的字节流服务
    - 面向连接：在交换数据之前需要先建立一个 TCP 连接
    - 可靠：拥有完善的拥塞控制、报文丢失处理机制
    - 仅有两方进行彼此通信
2. 报文格式
    - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/2B8834BBED9E4EF299D599EEF4B80E72/20123)
    - 源端口号+目的端口号+源IP地址+目的IP地址确定一个唯一TCP 连接
    - 序号标识从 TCP 发端向 TCP 收端发送的字节流，指向第一个数据字节（注意：SYN 与 FIN 各占一个序号）
    - 建立一个新连接时， SYN 标志变 1.
    - TCP 没有选择确认，确认序号表示已成功收到字节，但不包括序号所指的字节。
    - 首部长度代表首部中 32 bit 的数目（最多 60 字节的首部）
    - 标志比特
        - URG 紧急指针有效
        - ACK 确认序号有效
        - PSH 接收方应该尽快将这个报文段交给应用层
        - RST 重建连接
        - SYN 同步序号，用来建立一个连接
        - FIN 终止信号，用于结束一个连接
    - 窗口大小用于实现流量控制，单位为字节，16bit 可表示最大窗口 65536 字节，可以使用窗口扩大选项来提供更大的窗口
    - 检验和覆盖整个 TCP 报文段：首部+数据（计算方法和 UDP 一样，也要加入伪首部）
    - TCP 的选项和数据部分都是可选的，在建立或终止连接时，双方交换的报文仅有 TCP 首部

## 连接的建立与终止

1. 连接建立（三次握手
    1. 客户端发送一个 SYN + 初始序号的段给服务器，表明想建立一个连接
    2. 服务器发回包含服务器初始序号的SYN 报文段作文应答，同时，确认序号设置为客户的 ISN + 1 对客户的 SYN 报文段进行确认
    3. 客户端将确认序号设置为服务器的 ISN + 1 对服务器的报文段进行确认。（连接建立完成）
2. 初始序号（Initial Sequence Number）的选择
    - 随时间变化，并且每个连接的 ISN 都不同
3. 连接终止（四次挥手）
    - TCP 连接是全双工的，因此每个方向必须单独进行关闭，原则就是当一方完成数据发送任务后就可以发送一个 FIN 来终止这个方向的连接
    - 发送 FIN 通常是应用层关闭的结果
    - 过程
        1. 首先进行关闭的一方（通常是客户端）执行主动关闭，发送一个 FIN 报文段（FIN 占用一个序号）
        2. 服务器收到 FIN，将发回一个 ack，确认序号为接收到的序号 + 1，同时向应用程序传送一个文件结束符（这个过程是 TCP 模块自动发送的，不需要应用层干预）
        3. 服务器关闭连接，向客户端发送一个 FIN 报文
        4. 客户端发回一个确认，连接终止
4. 连接建立的超时
    - TCP 采用一种 500ms 的定时器
    - 建立连接请求发起时，会建立一个 6s 的超时器（12 个时钟滴答），除第一个 500ms 间隔，后面的每 500ms 超时计数器减1。但是第一个 500ms 是可变的，也就是可能在任意时刻超时计数器减 1. （与操作系统时钟类似，它不是设置一个精确的定时器，而是靠时钟中断来计算时间）
5. 最大报文段长度（MSS： Maximum Segment Size）
    - 指示TCP传往另一端的最大块数据的长度（不包含IP首部和TCP首部）
    - MSS 选项只能出现在 SYN 报文段中，用于在连接时通告自己的期望接收的报文大小
    - 如果一方不接收另一方的 MSS值，默认为536 字节
    - 计算方法：MSS = MTU - 20（固定IP首部长度） - 20（固定TCP首部长度）
6. TCP状态变迁图
    - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/9550A3199E554807AD78EA37C4D7B748/20203)
    - 正常连接建立终止状态图：![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/EFF3EEE32E104CFFA07848C86B6EE6C6/20205)
    - 2MSL状态（TIME_WAIT状态）
        - MSL（Maximum Segment Lifetime）是报文段被网络丢弃前的最大生存时间
        - 当TCP 执行主动关闭，并发回最后一个 ack，该连接必须在 TIME_WAIT 状态停留的时间为 2MSL，以便对方在没有收到 ack 的情况下重发 FIN 时能接收到并重发 ack
        - 在 2MSL 期间，这个端口不能再被使用，收到的任何报文段将被丢弃
            - 可以使用 `SO_REUSEADDR` 选项来重用一个端口，但是对于同一个插口对（源IP，源端口，目的IP，目的端口），是应该不允许一个新连接建立起来的，但是伯克利实现的TCP 允许一个新连接到达一个在 TIME_WAIT 状态的连接，只要新的序号大于前一个连接的最后序号
    - 复位报文段
        - 到不存在端口的连接请求
            - 端口没有进程监听，UDP 返回 ICMP 差错，TCP返回复位报文
        - 异常终止一个连接
            - 不发送 FIN，而是发送一个 复位报文来释放一个连接，称为异常释放
            - 收到 RST 报文的一方不会发送 ack，而是通知应用层，然后终止连接
        - 检测半打开
            - 一方异常终止，而另一方不知道，这样的连接称为半打开的。
            - 一方发送数据，异常终止的一方不认识报文中的连接，发回复位应答报文
7. 同时打开
    - 双方同时发送 SYN，接收到 SYN 后同时发送 ack
    - TCP对这种情况只会建立一条连接，而不是两条
    - 可能性很小，在当前客户端-服务器模型的情况下，是不可能出现的
8. 同时关闭
    - 双方同时执行主动关闭，发送 FIN 报文给对方
    - 收到 FIN 报文后发送 ack 报文，双方都进入 TIME_WAIT 状态
9. TCP 选项
    - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/4D8D628FF0F64A88BD74B394367904EF/20273)
    - 每个选项的开始是 1 字节的类型（kind），有的选项 kind 后面是长度（len），长度是选项的总长度，包括 kind 和 len 自身
    - NOP 字节是填充使用，将选项填充为 4字节的倍数
10. TCP 服务器的设计
    - 服务器端口号
        - local address 可以使用 * 表示连接请求能被服务器任意接口接收
    - 限定本地 IP 地址
        - 在TCP 监听时，指定要使用的接口 IP 地址
    - 限定远端 IP地址
        - API一般不支持，只能应用层自行过滤
    - 连接请求队列
        - 服务器一端有一个固定长度的连接队列，存储三次握手完成但还没有被应用层接受的连接
        - 应用层指明该队列的最大长度(backlog), 书中列举 backlog 是一个 0～5 的枚举值，但是在 Java 的 `ServerSocket` 注释中，backlog 可以是任意值，指明的就是队列的大小。
        - 新连接到达时，TCP 将根据队列的排队连接数来决定是否接收，如果队列中仍有空间，TCP 将对 SYN 进行确认，完成连接的建立；如果队列中没有空间，TCP 不响应 SYN 报文，不发回任何报文段，客户端在一段时间后超时。
    - 应用层接收到的连接是 TCP 已经完成三次握手的连接，应用层干预不了 TCP 的握手过程

## TCP 交互数据流

1. 交互数据：交互命令产生的数据流，对响应时间要求比较高
2. 延时 ack（书上翻译为经受时延的确认）
    - TCP 在收到数据时并不立即发送 ack，它会等待以便将 ack 与同方向的数据一起发送
    - 一般时延为 200ms
    - 实际观察中超时时间是随机的
    - 跟中断类似，TCP 使用 200ms 的类中断机制，TCP 设置 200ms 超时，但并不是精确的 200ms，而是设置一个中断点，当 200ms 到来时，就会触发中断点，即发送 ack
    - **不能认为 TCP 的软中断是以 100ms 为单位触发的，即上面说的 500ms 定时器与这里的 200ms 定时器是单独的，因为延时发送 ack 的时延可以在 100ms 以下，即设置 Nms 定时器，则在 1～N ms 之间都可能触发**
3. Nagle 算法
    - 微小分组在广域网上会增加拥塞出现的可能
    - 小分组的判定：要发送的字节数小于报文段(MSS)的大小
    - **Nagle 算法要求一个TCP 连接上最多只能有一个未被确认的小分组，在该分组确认到达之前不能发送其他的小分组，TCP 会收集这些小分组，在确认到来时以一个分组的形式发送出去**
    - 因此在有尚未确认数据的情况下， Nagle 算法阻止我们发送小的报文段
    - 使用 `TCP_NODELAY` 选项来禁用 Nagle 算法
4. 窗口大小通告
    - 窗口是TCP 缓存窗口大小
    - 在 TCP 缓冲区已经收到数据，而应用未能及时读取的情况下，窗口可用空间变小，两方通过通告各自的窗口大小来控制对方发送数据的速度

## TCP 的成块数据流

1. 隔一个报文段确认策略
    - 当 TCP 处理报文段 A 时，该连接标记产生一个延时 ack；TCP 处理下一报文段 B，由于现在有两个报文段需要确认，因此产生序号为 B+1 的ack，并清除连接产生的 延时ack 标记
2. 快的发送方和慢的接收方
    - 发送方发送接收方窗口大小的数据给接收方，然后停下来等待 ack，ack 中带有窗口大小，发送方可以继续发送指定窗口大小的数据块
    - 窗口更新：数据报文并不确认任何数据，只是用来增加窗口的右边沿
3. **滑动窗口**
    - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/02352B2EC19C44FEB08A919718397646/20402)
    - 窗口左边沿向右边沿靠近称为窗口合拢，发生在数据被发送和确认时
    - 窗口右边沿向右移动时将允许发送更多的数据，称为窗口张开，发生在另一段的接收进程读取已经确认的数据并释放 TCP 的接收缓存时（此时接收方会通告自己的窗口大小）。
    - 右边沿向左移动称为窗口收缩，不建议使用
    - 如果左边沿和右边沿重合，这是一个零窗口，此时不能发送任何数据
4. 窗口大小
    - 窗口即是接收方缓存的大小，
    - API 允许进程设置发送和接收缓存大小，接收缓存大小是能够通告的最大窗口
5. `PUSH` 标志
    - 发送方使用该标志通知接收方将所收到的数据立即全部提交给接收进程。数据包括与 PUSH 一起传送的数据和已经收到的数据
    - PUSH 标志用于指示接收端 TCP 不要因为等待额外数据而使已接收的数据在缓存中滞留
    - 如果待发送数据将清空发送缓存，则 TCP 可以自动设置 PUSH 标志
6. **慢启动（slow start）**
    - 拥塞窗口(congestion window) cwnd
    - 当与**另一个网络的主机**建立 TCP 连接时，拥塞窗口被初始化为 1个报文段，每收到一个 ack，拥塞窗口就增加一个报文段，发送方取拥塞窗口与通告窗口中的最小值作为发送上限
    - 拥塞窗口是发送方使用的流量控制，通告窗口则是接收方使用的流量控制
    - 指数增长
    - 当有报文超时，说明一次性发的数据过大，超时和重传机制会启用拥塞避免算法
7. 成块数据的吞吐量
    - 发送一个分组的时间取决于2个因素：传播时延+发送时延
    - 理想状态：不管管道上有多少报文段，返回路径上有相同数量的 ack
    - 带宽时延乘积（通道容量）
        - **capacity(bit) = bandwidth(b/s) * roundtrip time(s)**
        - 为达到最大吞吐量，接收方窗口的最小大小
    - 拥塞
        - 大的管道 -> 小的管道
        - 快速网络 -> 慢速网络
        - 会发生拥塞

## TCP 的超时与重传

1. TCP 提供可靠的运输层，使用的方法之一就是确认从另一端收到的数据
2. 定时器分类
    - 重传定时器：发送一个报文后，未收到对方的确认时，发起重传的定时器
    - 坚持定时器：使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口
    - 保活定时器：在连接空闲的时候，保持连接的连通性，检测连接是否还有效
    - 2MSL定时器：连接处于 TIME_WAIT 的时间
3. 重传策略
    - 指数退避
        - 每一次重传的超时时间为前一次的2倍，这个倍乘关系称为指数退避（exponential backoff）
    - 第一次超时时间为1.5s， 最大到64s
    - 首次分组传输与复位信号传输之间的时间差为 9 分钟，不可调整
4. RTT 测量
    - 低通平通 RTT 估计器 R：
        - R= 𝑎R+(1-𝑎)M
        - 𝑎是一个推荐值为0.9的平滑因子
        - M 为当前测量
    - 重传超时时间 RTO （Retransmission TimeOut）
        - RTO = Rℬ
        - ℬ 推荐值为 2 的时延离散因子
    - karn 算法
        - 重传多义性：超时发生时，重传这个分组，收到一个 ack ，无法确认这个 ack 是第一次还是重传的
        - 当一个超时和重传发生时，在重传数据的确认最后到达时，不能更新 RTT 估计器。
5. 快速重传算法： TCP 实现对收到的重复 ack 进行计数，当收到第3个时，就假定一个报文段已经丢失并重传自那个序号起的一个报文段
6. 拥塞避免算法
    - 慢启动算法是在一个连接上发起数据流的方法，但有时我们会到达中间路由器的极限，此时分组丢失，拥塞避免算法是一种处理丢失分组的方法
    - 假定：由于分组收到损坏引起的丢失是很少的，因此分组丢失就意味着发生了拥塞。
    - 拥塞发生的判断：发生超时和收到重复的确认
    - 算法工作过程
        - 初始化 cwnd 为 1个报文段， ssthresh（慢启动门限） 为 65535 字节
        - TCP 输出不能超过 cwnd 和接收方通告窗口的大小
        - 当拥塞发生时，ssthresh 被设置为当前窗口大小的一半（cwnd 和接收方通告窗口的最小值，但至少为2个报文段），如果是超时引起了拥塞，则 cwnd 被设置为 1个报文段
        - 当新的ack 到达，就增加 cwnd，但增加的方法依赖与我们正在进行慢启动还是拥塞避免。如果cwnd 小于或等于 ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的一半时才停止（ssthresh），然后转为拥塞避免
    - 拥塞避免算法要求每次收到一个ack 时将 cwnd 增加 1/cwnd，是一种加性增长
    - **Tahoe版本仅在对方处于一个不同的网络上时才进行慢启动，Reno 版本总是执行慢启动**
7. 快速重传和快速恢复算法
    - 如果一连串收到3个或3个以上的重复 ack， 我们就重传丢失的数据报文段，而不等待超时定时器溢出，这就是快速重传算法，接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。
    - 实现：
        - 当收到第3个重复ack 时，ssthresh = cwnd/2，重传丢失报文段，cwnd = ssthresh + 3MSS
        - 每次收到一个重复ack ，cwnd 增加一个报文段并发送 1个分组
        - 当下一个确认新数据的 ack 到达时，cwnd = ssthresh
8. 重新分组
    - TCP 超时并重传时，允许重新分组而发送一个较大的报文段，有助于提高性能。
    - 当然报文段不能超过 MSS

## TCP 坚持定时器

1. TCP 不对ack 报文进行 ack， 因此如果一个确认丢失了，而这个确认是增大通告窗口的，则双方就可能因为等待对方而使连接终止，发送方等待窗口更新，接收方等待数据，为防止这种死锁，**发送方使用一个坚持定时器（persist timer）来周期性的向接收方查询窗口是否已经更新**，这些报文称为窗口探查（window probe）
2. 坚持定时器总在 5～60s 之间，窗口探查包含一个字节的数据，与重传超时不同的是坚持定时器从不放弃发送窗口探查，每60s 发送一个窗口探查，直到接收方窗口更新或应用终止连接
3. 糊涂窗口综合症（Silly Window Syndrome）
    - 接收方通告一个小的窗口（而不是等待大窗口），发送方也发送少量数据（而不等待其他数据以发送一个大报文段）
    - 措施：
        - 接收方不通告小窗口，算法是接收方只有在窗口可以增加一个报文大小（接收方的MSS）或增加窗口大小的一半时才通告窗口
        - 发送方只有满足条件才发送数据：a）可以发送一个满长度的报文段；b）可以发送至少是接收方最大窗口大小一半的报文段；c）没有未ack 的数据且能够发送手头的所有数据或连接禁止了 Nagle 算法
4. [糊涂窗口综合症](https://zh.wikipedia.org/wiki/%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87)
    - 处理每个数据包都存在一定量的开销，数据包数的增加也可能使数据处理量减少。最终的结果就是**抖动**
    - 在糊涂窗口综合症期间，通信效率几乎为零，因此该问题的持续时间应尽可能短。

## TCP 的保活定时器

1. 如果 TCP 连接的双方都没有向对方发送数据，即两个TCP模块之间不交换任何信息，只要两端的主机没有被重启，则连接依然保持。
2. 另一方如果崩溃或关机或重启，则连接就不可用了，主机希望探查连接是否依然有效。
2. 缺陷：
    - 在两个端系统的网络出现故障（短暂故障）的时候，保活定时器可能会终止一个好的连接
    - 耗费不必要的带宽
    - 分组计费的网络上会加重花费
3. 保活报文发送后：
    - 客户端依然正常运行，则 TCP 正常响应保活报文，服务器复位保活定时器（定时两个小时），每次有应用数据发送时也会复位保活定时器
    - 客户端已经崩溃（正在重启或已经关闭），服务器收不到探查的响应，在75s 后超时，服务器总共发送10个探查，之间间隔 75s，最终服务器终止连接
    - 客户端已重启，服务器会收到一个复位响应
    - 客户端运行正常，但是服务不可达，这与第二种情形一样，服务器无法分辨这两者
4. 应用层一般会提供心跳检查，不应该依赖运输层提供的这个能力。

## TCP 的未来和性能

1. 路径 MTU
    - 连接建立时，TCP 使用输出接口或对端声明MSS 的最小 MTU 作为起始报文段大小，如果对端没有指定MSS，默认536
    - 选定了初始报文大小，所有TCP发送的IP数据报都设置 DF 标志，如果中间路由器需要进行分片，丢弃数据并产生 ICMP 需要分片差错
    - 收到ICMP差错后，TCP 减少报文段大小并重传。如果是一个较新的ICMP差错（这个差错ICMP中包含MTU大小），则报文段设置为下一跳的MTU 减去IP与TCP首部长度，如果是较旧的ICMP差错（不包含MTU大小，只是一个差错），则尝试下一个可能的最小 MTU。当这个重传发生时，拥塞窗口不发生变化，但启动慢启动。
2. 大分组还是小分组
    - 在路由器内部不花费时间的假设下，发送小分组（512字节）比发送大分组（4096字节）所需的总时间要小，因为中间路由器的空闲时间小
    - 在这个假设下，无论多大的数据量，512字节永远比4096字节传输所需要的时间少，但缓存、接收、发送、处理等时间绝不是可以忽略不计的。
3. 长肥管道
    - 具有大的带宽时延乘积的网络被称为长肥网络（long fat network LFN），运行在 LFN 上的 TCP连接称为长肥管道
    - 长肥管道需要更大的窗口
    - 序号回绕问题（使用时间戳选项的PAWS）
4. 千兆比网络
    - 在千兆比速率下，时延占据主导地位，带宽不再是限制
    - 时延是由光速限制的，不可减少。
    - 当考虑到分组需要建立和终止连接时，固定时延引起的后果更加糟糕
5. 窗口扩大选项
    - 窗口扩大选项使TCP的窗口定义从 16bit 增加到 32bit。
    - 选项使用一个移位计数器，取值为 0～14，相应的窗口大小为 **2^(16 + n)**,n 为计数器的值
    - 选项只能出现在 SYN 报文段中，为了使用窗口扩大，两端必须在它们的 SYN 报文段中发送这个选项，主动建立的一方在SYN中包含这个选项，被动建立连接的一方只能在接收到这个选项的SYN 后才可以发送这个选项。
    - 主动连接的一方发送一个窗口扩大因子，但是没有收到对端的窗口扩大选项，就将计数器设置为0.（与旧系统兼容）
    - TCP 根据接收缓存自动计算移位计数。
6. 时间戳选项
    - 时间戳选项使发送方在每个报文段中放置一个时间戳值，接收方在确认中返回这个数值，从而允许发送方为每一个收到的 ack 计算 RTT
    - 时间戳是一个单调递增的值（并不是真正的时间），接收方只需要回显收到的内容，因此不需要关心时间戳单位是什么
    - 推荐在 1ms ～ 1s 之间将时间戳加1，有些实现启动时将时间戳设置为在0，500ms 加 1
7. PAWS（Protection Against Wrapped Sequence numbers)回绕保护
    - 接收方将时间戳视为序号的32位扩展
    - PAWS 不需要两方之间进行任何时间同步，接收方只检查时间戳是否是单调递增的
8. T/TCP: 事务用的的 TCP扩展
    - 事务特征
        - 应该避免连接建立和终止的开销，在需要的时候，发送一个请求分组并接收一个应答分组
        - 等待时间应当减少到等于 RTT 和 SPT（Server Processing Time） 之和
        - 服务器应当能够检测出重复请求，并且重复请求不重新处理事务，直接返回保存的与请求对应的应答
    - [事务传输控制协议](https://zh.wikipedia.org/wiki/事务传输控制协议)
        - T/TCP 具有多种重大的安全问题（Charles Hannum 于1996年九月）[1][2]，因此它没有被广泛使用。 
9. TCP 的性能
    - 实际限制：
        - 不能比最慢的链路运行的更快
        - 不能比最慢的机器的内存运行的更快
        - 不能比接收方提供的窗口大小除以往返时间所得结果运行的更快
    - TCP 的最高运行速率上限是由 TCP的窗口大小和光速决定的
