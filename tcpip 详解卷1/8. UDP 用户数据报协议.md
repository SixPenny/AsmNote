81. 面向数据报，运输层协议
2. 特点
    - 不提供可靠性
    - 应用必须关心IP 数据报的长度(分片)
3. UDP 格式
    - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/AB4150F417A9487CBF4C11D97CD0D566/19532)
    - 端口号表示发送进程和接收进程
    - 长度字段指首部与数据的总长度（冗余的）
    - 检验和覆盖首部和数据
        - 计算方法
            - 16bit 字的二进制反码和
            - 数据长度可以为奇数字节，在计算检验和是需要填充字节，但是填充字节不被发送
            - UDP和TCP都包含12字节的伪首部，只是为了计算检验和而设置的（让UDP 检查数据报是否正确到达目的地）。
            - 检验和计算还包括伪首部
            - ![](https://note.youdao.com/yws/public/resource/7892244109fc75f249e4a20f1c461bdc/xmlnote/A2059933007F41BA953FBBE1E28BB2D8/19528)
    - 如果发送端没有计算检验和而接收端检测到检验和有差错，UDP 数据报就被悄悄丢弃，无任何差错报文产生
    - **虽然链路层如以太网有循环冗余校验，但在数据通过路由器时，数据报依然可能产生差错，因此UDP的检验和是必要的**
    - **不要完全相信数据链路的crc 检验，应该始终打开端到端的检验和功能，而且如果你的数据很有价值，也不要完全相信UDP，TCP 的检验和，因为这些都只是简单的检验和，不能检测出所有可能的差错**
4. 客户端使用的临时端口号在 `1024~5000` 之间
5. IP 分片
    - 如果IP 数据报长度大于MTU，则需要进行分片（可以在源主机上，也可能在路由器上）
    - 分片以后，只有到达目的地后才进行重新组装，由IP层完成
    - 分片过的数据报可能再次进行分片
    - IP 首部分片字段见[Flags&Fragment Offset 协议字段](https://github.com/SixPenny/Note/blob/master/tcpip%20%E8%AF%A6%E8%A7%A3%E5%8D%B71/3.%20IP%20%E5%B1%82.md)
    - 尽管IP分片是透明的，但是即使只丢失一片数据也需要重传整个数据报，因此要避免分片
    - 在分片时，除最后一片，每一片的数据部分必须是8字节的整数倍
    - `(frag 26304:1480@0+)`, `(frag 26304:1@1480)` `26304` 是IP报文的标识符，`1480` 和 `1`表示数据的长度，`0` 和 `1480`表示偏移长度，`+`表示还有更多分片
    - 前面说的 ICMP 携带 IP 数据报数据的前8个字节，在 IP 有分片的情况下，这8个字节可能不包含UDP 端口号
6. ICMP 不可达差错（需要分片）
    - 路由器收到一份需要分片的数据报，但是IP层的不分片标志被设置
    - 可以根据这个差错判断路径 MTU
7. 采用 UDP的路径MTU发现
    - `ip_path_mtu_discovery` 选项打开或关闭路径MTU 发现
    - 如果允许路径MTU发现，那么当UDP应用程序写入可能被分片数据报时，该数据报被丢弃
    - 所以这个选项最好不要打开
8. UDP 与ARP 的交互作用
    - 当ARP缓存还是空的时候。UDP在被发送之前一定要发送一个ARP请求来获得目的主机的MAC地址，如果这个UDP的数据包足够大，大到IP层一定要对其进行分片的时候，想象中，该UDP数据包的第一个分片会发出一个ARP查询请求，所有的分片都会 等到这个查询完成以后再发送。
    - 结果是，某些系统会让每一个分片都发送一个ARP查询，所有的分片都在等待，但是接受到第一个回应的时候（因为arp队列是后入先出的，所以最后一个分片反而第一个获得响应），主机却只发送了最后一个数据片而抛弃了其他（只发送了ip数据报的最后一个分片，前面的分片却没有发送，因为前面的分片没有等到arp 响应），这实在是让人匪夷所思（这实际上是ARP的正常操作。在大多数的实现中，等待一个ARP应答时，只将最后一个报文发送给特定目的主机）。这样，因为分片的数据不能被及时组装，接受主机将会在一段时间内（30s或60s）将永远无法组装的IP数据包抛弃，并且发送组装超时的ICMP报文（其实很多系统不产生这个差错），以保证接收主机自己的接收端缓存不被那些永远得不到组装的分片充满。
9. 最大UDP数据报长度
    - 大多数实现提供的长度比65535小
    - tcp/ip的实现特性，会使IP数据报长度小于65535字节
    - 数据报截断
        - 应用程序指定每次返回的最大字节数
        - 如果数据报文大于指定的值呢？答案取决于编程接口和具体实现
        - **因此设计UDP程序时，应用程序限制最好在512字节以下。**
10. ICMP 源站抑制差错
    - 当接收端的处理速度比接收速度慢时，报文会将接收端的缓存填满，后续报文会被丢弃，可能产生这个差错（不要求必须产生）
11. UDP 服务器设计
    - 目的IP地址
        - 应用程序应该知晓数据报是发送给谁的，即目的IP地址，这样应用可以判断数据报是否是广播数据报
    - UDP 输入队列
        - 程序所使用的每个端口都与一个有限大小的队列相联系
        - 顺序到来的数据报将在UDP自动排队
        - **排队溢出会造成内核中的UDP模块丢弃数据报**
        - 而这是应用程序不知道的
12. 限制本地IP地址
    - 大多数UDP 服务器在创建UDP 端点时在服务器的所有接口上开启监听
    - 服务器在创建时，可以指定本机的某个IP地址包括广播地址为端点的本地地址
    - 可以在相同的端口上启动不同的服务器，每个服务器具有不同的本地地址，除第一个启动的服务器，后面在启动时需要指定使用 `SO_REUSEADDR` 选项
13. 限制远端 IP
    - `netstat -ant` 的输出中，`Foreign Address `显示的时`*.*`,表示可以接受任何IP ，任何端口的数据报
    - 可以限制只接收指定 IP，指定端口的数据报
14. 端口有多个接收者
    - 一般情况下，只允许一个程序端点与某个本地IP地址和UDP端口相关联
    - 在支持多播的系统上，多个端点可以使用同一个IP地址和UDP端口号（也需要指定`SO_REUSEADDR` 选项，BSD 所有的端点还需要设置一个`SO_REUSEPORT` 选项） 
    - 当 UDP数据报到达的目的地址为多播或广播地址，而且在目的地址和端口处有多个监听端点时，就向每个端点传送一份数据报的复制。
    - 如果UDP 数据报是一个单播地址，那么只向其中一个端点传送数据报，选择哪个端点取决于系统实现
15. RFC 参考
    - [RFC 768](https://tools.ietf.org/pdf/rfc768.pdf)
        - Checksum is the 16-bit one’s complement of the one’s complement sum of a pseudo header of information from the IP header, the UDP header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
    - [UDP Best Practice](https://tools.ietf.org/html/rfc8085)
